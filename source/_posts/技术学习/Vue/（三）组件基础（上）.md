---
title: （三）组件基础（上）
tags:
  - Vue3
categories:
  - 技术学习
  - Vue
cover: '/assets/img/post/vuejs.webp'
abbrlink: 56ee636f
date: 2022-04-23 10:47:58
---

# 单页面应用程序

## 1.什么是单页面应用程序

单页面应用程序（英文名：Single Page Application)简称SPA,顾
名思义，指的是一个Wb网站中只有唯一的一个HTML页面，所有的
功能与交互都在这唯一的一个页面内完成。

## 2.单页面应用程序的特点

单页面应用程序将所有的功能局限于一个Wb页面中，仅在该web页面初始化时加载相应的资源（HTML、JavaScript和CSS)。

一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用JavaScript动态地变换HTML的内容，从而实现页面与用户的交互。

## 3.单页面应用程序的优点

SPA单页面应用程序最显著的3个优点如下：

①良好的交互体验

- 单页应用的内容的改变不需要重新加载整个页面
- 获取数据也是通过AjaX异步获取
- 没有页面之间的跳转，不会出现“白屏现象”

②良好的前后端工作分离模式

- 后端专注于提供API接口，更易实现API接口的复用
- 前端专注于页面的渲染，更利于前端工程化的发展

③减轻服务器的压力

- 服务器只提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍

## 4.单页面应用程序的缺点

任何一种技术都有自己的局限性，对于SPA单页面应用程序来说，主要的缺点有如下两个：

①首屏加载慢

- 路由懒加载
- 代码压缩
- CDN加速
- 网络传输压缩

②不利于SE0

- SSR服务器端渲染

## 5.如何快速创建vue的SPA项目

Vue官方提供了两种快速创建工程化的SPA项目的方式：
①基于vite创建SPA项目
②基于vue-cli创建SPA项目

![image-20220425111213863](/assets/img/article/image-20220425111213863.png)

# vite的基本使用

## 1.创建vite的项目

按照顺序执行如下的命令，即可基于vite创建Vue3.x的工程化项目：

![image-20220425111317486](/assets/img/article/image-20220425111317486.png)

## 2.梳理项目的结构

使用vite创建的项目结构如下：

![image-20220425111351737](/assets/img/article/image-20220425111351737.png)

其中：
●node modules目录用来存放第三方依赖包
●public是公共的静态资源目录
●src是项目的源代码目录（程序员写的所有代码都要放在此目录下）
●.gitignore是Git的忽略文件
●index.html是SPA单页面应用程序中唯一的HTML页面
●package.json是项目的包管理配置文件

在src这个项目源代码目录之下，包含了如下的文件和文件夹：

![image-20220425111559116](/assets/img/article/image-20220425111559116.png)

其中：
●assets目录用来存放项目中所有的静态资源文件(css、fonts等)
●components目录用来存放项目中所有的自定义组件
●App.Vue是项目的根组件
●index.css是项目的全局样式表文件
●main.js是整个项目的打包入口文件

## 3.vite项目的运行流程

在工程化的项目中，vue要做的事情很单纯：通过main.js把App.vue渲染到index.html的指定区域中。
其中：
①App.vue用来编写待渲染的模板结构
②index.html中需要预留一个el区域
③main.js把App.vue渲染到了index.html所预留的区域中

### 3.1在App.Vue中编写模板结构

清空App.vue的默认内容，并书写如下的模板结构：

![image-20220425111814922](/assets/img/article/image-20220425111814922.png)

### 3.2在index.html中预留el区域

打开index.html页面，确认预留了el区域：

![image-20220425111840707](/assets/img/article/image-20220425111840707.png)

### 3.3在main.js中进行渲染

按照vue3.x的标准用法，把App.vue中的模板内容渲染到index.html页面的el区域中：

![image-20220425111919009](/assets/img/article/image-20220425111919009.png)

# 组件化开发思想

## 1.什么是组件化开发

组件化开发指的是：根据封装的思想，把页面上可重用的部分封装为组件，从而方便项目的开发和维护。

## 2.组件化开发的好处

前端组件化开发的好处主要体现在以下两方面：
提高了前端代码的复用性和灵活性
提升了开发效率和后期的可维护性

## 3.vue 中的组件化开发

vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是.vue。之前接触到的 App.vue 文件本质上就是一个vue的组件。

# Vue组件的构成

## 1. vue 组件组成结构

每个 .vue 组件都由 3 部分构成，分别是：

- template -> 组件的模板结构
- script -> 组件的 JavaScript行为
- style -> 组件的样式

其中，每个组件中必须包含template模板结构，而script行为和style 样式是可选的组成部分。

## 2.组件的template 节点

vue 规定：每个组件对应的模板结构，需要定义到`<template>` 节点中。

![image-20220425112330088](/assets/img/article/image-20220425112330088.png)

注意：`<template>`是vue提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的DOM元素。

### 2.1在template中使用指令

在组件的`<template>`节点中，支持使用前面所学的指令语法，来辅助开发者渲染当前组件的DOM结构。
代码示例如下：

![image-20220425112438715](/assets/img/article/image-20220425112438715.png)

### 2.2在template中定义根节点

在vue2.x的版本中，`<template>`节点内的DOM结构仅支持单个根节点：

![image-20220425112520544](/assets/img/article/image-20220425112520544.png)

但是，在vue3.x的版本中，`<template>`中支持定义多个根节点：

![image-20220425112540733](/assets/img/article/image-20220425112540733.png)

## 3.组件的script节点

vue规定：组件内的`<script>`节点是可选的，开发者可以在`<script>`节点中封装组件的JavaScript业务逻辑。

`<script>`节点的基本结构如下：

![image-20220425112656371](/assets/img/article/image-20220425112656371.png)

### 3.1 script中的name节点

可以通过name节点为当前组件定义一个名称：

![image-20220425112728261](/assets/img/article/image-20220425112728261.png)

在使用vue-devtools进行项目调试的时候，自定义的组件名称可以请晰的区分每个组件：

![image-20220425112753494](/assets/img/article/image-20220425112753494.png)

### 3.2 script中的data节点

vue组件渲染期间需要用到的数据，可以定义在data节点中：

![image-20220425112814757](/assets/img/article/image-20220425112814757.png)

#### 组件中的data必须是函数

vue规定：组件中的data必须是一个函数，不能直接指向一个数据对象。因此在组件中定义data数据节点时，下面的方式是错误的：

![image-20220425112855035](/assets/img/article/image-20220425112855035.png)

### 3.3 script中的methods节点

组件中的事件处理函数，必须定义到methods节点中，示例代码如下：

![image-20220425112923348](/assets/img/article/image-20220425112923348.png)

## 4.组件的style节点

vue规定：组件内的`<style>`节点是可选的，开发者可以在`<style>`节点中编写样式美化当前组件的UI结构。

`<script>`节点的基本结构如下：
![image-20220425113009746](/assets/img/article/image-20220425113009746.png)

其中`<style>`标签上的lang="css"属性是可选的，它表示所使用的样式语言。默认只支持普通的css语法，可选值还有less、scss等。

### 4.1让style中支持less语法

如果希望使用less语法编写组件的style样式，可以按照如下两个步骤进行配置：
①运行`npm install less -D`命令安装依赖包，从而提供less语法的编译支持
②在`<style>`标签上添加lang="Less"属性，即可使用less语法编写组件的样式

![image-20220425113102067](/assets/img/article/image-20220425113102067.png)

# 组件的基本使用

## 1.组件的注册

组件之间可以进行相互的引用，
例如：

![image-20220425113155515](/assets/img/article/image-20220425113155515.png)

Vue中组件的引用原则：先注册后使用

### 1.1 注册组件的两种方式

vue中注册组件的方式分为“全局注册”和“局部注册”
两种，其中：

- 被全局注册的组件,可以在全局任何一个组件内使用
- 被局部注册的组件，只能在当前注册的范围内使用

![image-20220425113259256](/assets/img/article/image-20220425113259256.png)

### 1.2全局注册组件

![image-20220425113322773](/assets/img/article/image-20220425113322773.png)

### 1.3 使用全局注册组件

使用`app.component()` 方法注册的全局组件, 直接以标签的形式进行使用

![image-20220425113403591](/assets/img/article/image-20220425113403591.png)

### 1.4 局部注册组件

![image-20220425113435196](/assets/img/article/image-20220425113435196.png)

### 1.5 全局注册和局部注册的区别

- 被全局注册的组件，可以在全局任何一个组件内使用
- 被局部注册的组件,只能在当前注册的范围内使用

应用场景：

- 如果某些组件在开发期间的使用频率很高，推荐进行全局注册；
- 如果某些组件只在特定的情况下会被用到，推荐进行局部注册。

### 1.6 组件注册时名称的大小写

在进行组件的注册时，定义组件注册名称的方式有两种：

① 使用 kebab-case 命名法（俗称短横线命名法，例如my-swiper和my-search)
② 使用 PascalCase 命名法（俗称帕斯卡命名法或大驼峰命名法，例如MySwiper和MySearch）

短横线命名法的特点：

- 必须严格按照短横线名称进行使用

帕斯卡命名法的特点：

- 既可以严格按照帕斯卡名称进行使用，又可以转化为短横线名称进行使用

注意：在实际开发中，推荐使用帕斯卡命名法为组件注册名称，因为它的适用性更强。

### 1.7通过name属性注册组件

在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的name属性作为注册后组件的名称，
示例代码如下：
![image-20220425113724876](/assets/img/article/image-20220425113724876.png)

## 2.组件之间的样式冲突问题

默认情况下，写在.vue组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。导致组件之间样式冲突的根本原因是：

①单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的
②每个组件中的样式，都会影响整个index.html页面中的DO元素

### 2.1思考：如何解决组件样式冲突的问题

为每个组件分配唯一的自定义属性，在编写组件样式时，通过属性选择器来控制样式的作用域，示例代码如下：

![image-20220425113918014](/assets/img/article/image-20220425113918014.png)

### 2.2 style节点的scoped属性

为了提高开发效率和开发体验，vue为style节点提供了scoped属性从而防止组件之间的样式冲突问题：

![image-20220426063217908](/assets/img/article/image-20220426063217908.png)

### 2.3/deep/样式穿透

如果给当前组件的style节点添加了scoped属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用/deep/深度选择器。

![image-20220426063819478](/assets/img/article/image-20220426063819478.png)

注意:`/deep/`是vue2.x中实现样式穿透的方案。在vue3.x中推荐使用`:deep()`替代`/deep/`。

## 3.组件的props

为了提高组件的复用性，在封装vue 组件时需要遵守如下的原则:

- 组件的DOM结构、Style样式要尽量复用
- 组件中要展示的数据，尽量由组件的使用者提供

为了方便使用者为组件提供要展示的数据，vue组件提供了props的概念。

### 3.1什么是组件的props

props是组件的自定义属性，组件的使用者可以通过props把数据传递到子组件内部，供子组件内部进行使用。代码示例如下:

![image-20220426064350275](/assets/img/article/image-20220426064350275.png)

props的作用:父组件通过props向子组件传递要展示的数据。

props 的好处:提高了组件的复用性。

### 3.2在组件中声明props

在封装vue组件时，可以把动态的数据项声明为props自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。示例代码如下:

![image-20220426071211415](/assets/img/article/image-20220426071211415.png)

### 3.3无法使用未声明的props

如果父组件给子组件传递了未声明的props属性，则这些属性会被忽略,。无法被子组件使用，示例代码如下:

![image-20220426073114119](/assets/img/article/image-20220426073114119.png)

### 3.4动态绑定props的值

可以使用v-bind 属性绑定的形式，为组件动态绑定props 的值，示例代码如下:

![image-20220426073752522](/assets/img/article/image-20220426073752522.png)

### 3.5 props的大小写命名

组件中如果使用“camelCase(驼峰命名法)”声明了props属性的名称，则有两种方式为其绑定属性的值:

![image-20220426074054098](/assets/img/article/image-20220426074054098.png)

## 4.Class 与Style绑定

在实际开发中经常会遇到动态操作元素样式的需求。因此，vue允许开发者通过v-bind属性绑定指令，为元素动态绑定class属性的值和行内的style样式。

### 4.1动态绑定HTML的class

可以通过三元表达式，动态的为元素绑定class的类名。示例代码如下;

![image-20220426074218954](/assets/img/article/image-20220426074218954.png)

### 4.2以数组语法绑定HTML的class

如果元素需要动态绑定多个class的类名，此时可以使用数组的语法格式：

![image-20220426074652933](/assets/img/article/image-20220426074652933.png)

### 4.3以对象语法绑定HTML的class

使用数组语法动态绑定class会导致模板结构臃肿的问题。此时可以使用对象语法进行简化：

![image-20220426075628361](/assets/img/article/image-20220426075628361.png)

### 4.4以对象语法绑定内联的style

:style的对象语法十分直观——看着非常像CSS，但其实是一个JavaScript对象。CSS property名可以用驼峰式(camelCase)或短横线分隔(kebab-case，记得用引号括起来)来命名:

![image-20220426075729632](/assets/img/article/image-20220426075729632.png)

# 封装组件的案例
